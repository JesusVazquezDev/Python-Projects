# Part A:

## Recovered password

a) 25207039

b) 03946715

## Pseudocode for attack

The algorithm is brute force algorithm. All possible numeric digit only passwords are generated from 1 to 8 digits. Each password that is generated is sha256 hashed with the given username and salt. When the result of this hash is equal to the given hash, the algorithm has found the desired password and will print it to the console.

## Worst case running time

The worst case running time occurs when the password is 99999999. In this situation --  111,111,110 passwords will be generated and checked.

## Discussion of current proposal and suggestions for improvement

The problem with the current proposal is that while random, the salt value is still known by the attacker. So cracking the password is still possible with brute force, because the only unkown value getting passed to the hash function is the password itself.

To improve upon the current proposal, and additional "pepper" value should be added to the hash. But instead of storing the pepper value in the database along with the other values, the pepper should be a global value that is stored separately (and therefore not known by the attacker).

# Part B:

## Discussion of the current scheme

The problem with the current scheme is that the IV value can be extracted directly from the cipher text with tag. Once the attacker gets this IV value, they can derive a malicious IV based on malicious plain text and add it back to the cipher text with tag. When the cipher text is decrypted, the assumed "safe" IV is used to decrypt the message. But since the IV has been strategically changed, the message could be different than what was orignally sent.

## Suggestions for improving the scheme

To improve the current scheme, the IV should be included in the cipher text in a spot OTHER than the first 16 bytes. This makes the scheme assymetric and more secure.


# Part C:

## Secret code

3776f87e-699572e3

## Explanation

First, a private key x is generated by the client, using the given EC_CURVE. g^x is then found by taking the public key of x. The bytes of g^x are then sent to the server using the provided API, and g^y bytes are received back from the server (after some parsing). g^xy is then found by calling exchange() on the original private key x, with the g^y received from the server passed as an argument. g^xy is then passed to the given code and the secret code is calculated.

# Extra Credit

Password = Badger1!

## Pseudocode
Password can be one of 4 combinations: 
	A-Z 		a-z	 	0-9
	A-Z 		a-z 		Punc
	A-Z 		Punc 	0-9
	a-z 		Punc 	0-9

Thus, we iterate through the dataset, 
	if len(password) < 6:
		Move to the next password. 

	if any character in the password is a int:
			A-Z 		Punc 	0-9
			a-z 		Punc 	0-9
			A-Z 		a-z	 	0-9
		We know it can only be 3 different combinations.
		if any character is an UpperCase Alpha(A-Z):
			We now only 2 options available 
				A-Z 		Punc 	0-9
				A-Z 		a-z	 	0-9
				check if LowerCase Alpha(a-z) is present
					VALID: A-Z 		a-z	 	0-9
				check if punctuation is present
					VALID: A-Z 		Punc 	0-9
				else:
					INVALID Password.

We do this for all possible combinations:
Comb1 =  A-Z 		a-z	 	0-9
Comb2 =  a-z 		Punc 	0-9
Comb3 =  A-Z 		a-z 		Punc
Comb4 =  A-Z 		Punc 	0-9

Psuedocode: 
	for password in password_list:
		if(comb1 == true):
			process the hash and check for equality
			if found, break and print password
		elif(comb2 == true):
			process the hash and check for equality
			if found, break and print password
		elif(comb3 == true):
			process the hash and check for equality
			if found, break and print password
		elif(comb4== true):
			process the hash and check for equality
			if found, break and print password
		else:
			continue to next password

Bruteforcing through the list, we end up discovering the password. 
Time Complexity(Size of password dictionary(n))


